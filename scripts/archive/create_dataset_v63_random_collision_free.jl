#!/usr/bin/env julia
"""
VAE Training Data Collection for v6.3: Controller-Bias-Free Architecture

CRITICAL DESIGN CHANGE from v6.2:
  ❌ v6.2: Used FEP-based controller (compute_action_v61) → introduces controller bias
  ✅ v6.3: Uses random walk + geometric collision avoidance → NO controller bias

Purpose:
  Generate UNBIASED training dataset for VAE learning:
  - Random walk with goal bias (no FEP optimization)
  - Geometric collision avoidance (repulsive forces)
  - Guarantees collision-free trajectories (distance > safety_threshold)
  - Diverse state-action coverage without controller assumptions

Data Architecture:
  - Raw trajectories: (pos, vel, u, heading, goal, d_pref, group)
  - SPMs computed during collection but NOT stored (reconstructed during training)
  - Extended logs: collision flags, emergency events
  - Storage: ~20 MB per simulation (slightly larger than v6.2 due to extra fields)

Configuration:
  - D_max = 8.0m (same as v6.2 for consistency)
  - Safety threshold = 3.0m (hard collision avoidance)
  - Exploration noise = 0.5 std (diverse behaviors)
  - Repulsion strength = 1.0 (tunable)
  - Multiple scenarios: Scramble crossing + Corridor
  - Multiple density conditions: 5, 10, 15, 20 agents/group
  - Corridor width variation: 8m, 10m, 12m (free space between walls, ~50% of world_y=20m)
  - 5 random seeds per condition

Target Collision Rate: < 0.1% (vs v6.2: ~12.5%)

Output:
  - Raw trajectories: data/vae_training/raw_v63/v63_{scenario}_d{density}_s{seed}_YYYYMMDD_HHMMSS.h5
  - Extended HDF5 structure with goal, d_pref, group, collision flags

Estimated time: ~3 hours (80 simulations × ~135s/run)

Academic Justification:
  This addresses the reviewer concern: "How can you claim unbiased VAE learning
  when training data was generated by the FEP controller itself?"
"""

using Pkg
Pkg.activate(".")

using Printf
using Statistics
using HDF5
using Dates
using Random
using LinearAlgebra
using ArgParse

# Load project modules
include("../src/config.jl")
include("../src/spm.jl")
include("../src/dynamics.jl")
include("../src/prediction.jl")
include("../src/action_vae.jl")
include("../src/controller.jl")
include("../src/scenarios.jl")
include("../src/logger.jl")

using .Config
using .SPM
using .Dynamics
using .Prediction
using .Controller
using .ActionVAEModel
using .Scenarios
using .Logger

"""
Parse command line arguments
"""
function parse_commandline()
    s = ArgParseSettings(description="VAE Training Data Collection v6.3 (Controller-Bias-Free)")

    @add_arg_table! s begin
        "--scenario"
            help = "Scenario type: 'scramble', 'corridor', or 'both'"
            arg_type = String
            default = "both"
        "--densities"
            help = "Agent densities (comma-separated, e.g., '5,10,15,20')"
            arg_type = String
            default = "5,10,15,20"
        "--seeds"
            help = "Random seeds (range format, e.g., '1:5')"
            arg_type = String
            default = "1:5"
        "--steps"
            help = "Simulation steps per run"
            arg_type = Int
            default = 3000
        "--corridor-widths"
            help = "Corridor widths in meters (comma-separated, e.g., '8,10,12')"
            arg_type = String
            default = "8,10,12"
        "--exploration-noise"
            help = "Exploration noise std for action diversity"
            arg_type = Float64
            default = 0.3
        "--safety-threshold"
            help = "Minimum distance to maintain (meters)"
            arg_type = Float64
            default = 4.0
        "--repulsion-strength"
            help = "Strength of repulsive force"
            arg_type = Float64
            default = 2.0
        "--output-dir"
            help = "Output directory for raw logs"
            arg_type = String
            default = "data/vae_training/raw_v63"
        "--dry-run"
            help = "Test mode: only 100 steps"
            action = :store_true
    end

    return parse_args(s)
end

println("="^80)
println("VAE Training Data Collection v6.3: Controller-Bias-Free")
println("="^80)
println()

# Parse arguments
args = parse_commandline()

# Configuration
const OUTPUT_DIR = args["output-dir"]
mkpath(OUTPUT_DIR)

const SCENARIOS = args["scenario"] == "both" ? ["scramble", "corridor"] : [args["scenario"]]
const DENSITIES = parse.(Int, split(args["densities"], ","))
const SEEDS_RANGE = let
    range_str = args["seeds"]
    if contains(range_str, ":")
        start_end = parse.(Int, split(range_str, ":"))
        collect(start_end[1]:start_end[2])
    else
        parse.(Int, split(range_str, ","))
    end
end
const MAX_STEPS = args["dry-run"] ? 100 : args["steps"]
const CORRIDOR_WIDTHS = parse.(Float64, split(args["corridor-widths"], ","))
const EXPLORATION_NOISE = args["exploration-noise"]
const SAFETY_THRESHOLD = args["safety-threshold"]
const REPULSION_STRENGTH = args["repulsion-strength"]

# v6.3 SPM parameters (optimized for human cognitive range)
const V63_SPM_PARAMS = SPMParams(n_rho=12, n_theta=12, sensing_ratio=3.0)  # D_max = 6.0m, 12x12 grid

println("Configuration:")
println("  Controller: Random Walk + Geometric Collision Avoidance (v6.3)")
println("  Scenarios: $(SCENARIOS)")
println("  Densities: $(DENSITIES)")
println("  Seeds: $(SEEDS_RANGE)")
println("  Steps per run: $(MAX_STEPS)")
println("  Corridor widths: $(CORRIDOR_WIDTHS) m")
println("  Exploration noise: $(EXPLORATION_NOISE) std")
println("  Safety threshold: $(SAFETY_THRESHOLD) m")
println("  Repulsion strength: $(REPULSION_STRENGTH)")
println("  D_max: 6.0m (12x12 grid)")
println("  Data format: Raw trajectories + extended logs")
println("  Output: $OUTPUT_DIR")
println()

"""
Run single simulation and save log
"""
function run_single_simulation(
    scenario::String,
    density::Int,
    seed::Int,
    corridor_width::Float64=40.0
)
    Random.seed!(seed)

    timestamp = Dates.format(now(), "yyyymmdd_HHMMSS")
    scenario_suffix = scenario == "corridor" ? "_w$(Int(round(corridor_width)))" : ""
    log_filename = "v63_$(scenario)$(scenario_suffix)_d$(density)_s$(seed)_$(timestamp).h5"
    log_path = joinpath(OUTPUT_DIR, log_filename)

    println("  Scenario=$scenario, Density=$density, Seed=$seed$(scenario == "corridor" ? ", Width=$(corridor_width)m" : "")")
    println("    Output: $log_filename")

    # Initialize agent params
    # v6.3: Use u_max=2.0 for unicycle model (velocity command, not force)
    # Human walking speed: 1.3-1.5 m/s, max ~2.0 m/s
    agent_params = AgentParams(n_agents_per_group=density, u_max=2.0)

    # Initialize SPM config with D_max=8.0m
    spm_config = init_spm(V63_SPM_PARAMS)

    # Create scenario first to get world_size
    if scenario == "scramble"
        agents, scenario_params = initialize_scenario(
            SCRAMBLE_CROSSING,
            density;
            seed=seed
        )
        obstacles = get_obstacles(scenario_params)
    elseif scenario == "corridor"
        agents, scenario_params = initialize_scenario(
            CORRIDOR,
            density;
            seed=seed,
            corridor_width=corridor_width
        )
        obstacles = get_obstacles(scenario_params)
    else
        error("Unknown scenario: $scenario")
    end

    # Initialize world params with scenario's world_size
    world_x, world_y = scenario_params.world_size
    world_params = WorldParams(
        width=world_x,
        height=world_y,
        max_steps=MAX_STEPS
    )

    # Tracking metrics
    collision_count = 0
    freezing_count = 0
    near_collision_count = 0  # Distance < safety_threshold

    # v6.3: Extended data storage
    action_log = zeros(Float32, MAX_STEPS, length(agents), 2)
    pos_log = zeros(Float32, MAX_STEPS, length(agents), 2)
    vel_log = zeros(Float32, MAX_STEPS, length(agents), 2)
    heading_log = zeros(Float32, MAX_STEPS, length(agents))

    # NEW in v6.3: Extended logs
    goal_log = zeros(Float32, length(agents), 2)  # Goal direction vector per agent
    d_pref_log = zeros(Float32, MAX_STEPS, length(agents), 2)  # Preferred direction
    group_log = zeros(Int32, length(agents))  # Agent group ID
    collision_flag_log = zeros(Bool, MAX_STEPS, length(agents))  # Collision event flag
    near_collision_flag_log = zeros(Bool, MAX_STEPS, length(agents))  # Near-collision flag

    # Store static data (goal is now a direction vector)
    for (idx, agent) in enumerate(agents)
        goal_log[idx, :] = agent.goal  # Direction vector
        group_log[idx] = Int32(agent.group)
    end

    # Simulation loop
    for step in 1:MAX_STEPS
        # Update each agent
        for (agent_idx, agent) in enumerate(agents)
            # Get other agents (excluding self)
            other_agents = filter(a -> a.id != agent.id, agents)

            # Compute preferred direction (agent.goal is now a direction vector)
            d_pref = agent.goal  # Direction vector (already normalized)

            # Log preferred direction
            d_pref_log[step, agent_idx, :] = d_pref

            # v6.3: Controller-Bias-Free Action Generation
            u = compute_action_random_collision_free(
                agent,
                other_agents,
                obstacles,
                agent_params,
                world_params;
                exploration_noise=EXPLORATION_NOISE,
                safety_threshold=SAFETY_THRESHOLD,
                repulsion_strength=REPULSION_STRENGTH
            )

            # Collision detection (for metrics only, no emergency stop)
            in_collision = false
            in_near_collision = false
            min_dist_agents = Inf
            min_dist_obstacles = Inf

            for other in other_agents
                dist = norm(agent.pos - other.pos)
                min_dist_agents = min(min_dist_agents, dist)

                if dist < agent_params.emergency_threshold_agent
                    in_collision = true
                    collision_count += 1
                elseif dist < SAFETY_THRESHOLD
                    in_near_collision = true
                    near_collision_count += 1
                end
            end

            # Check obstacle collisions
            if !isempty(obstacles)
                for obs in obstacles
                    obs_pos = [obs[1], obs[2]]
                    dist = norm(agent.pos - obs_pos)
                    min_dist_obstacles = min(min_dist_obstacles, dist)

                    if dist < agent_params.r_agent
                        in_collision = true
                        collision_count += 1
                    elseif dist < SAFETY_THRESHOLD
                        in_near_collision = true
                        near_collision_count += 1
                    end
                end
            end

            # Log collision flags
            collision_flag_log[step, agent_idx] = in_collision
            near_collision_flag_log[step, agent_idx] = in_near_collision

            # Compute heading from velocity
            heading = norm(agent.vel) > 1e-6 ? atan(agent.vel[2], agent.vel[1]) : 0.0

            # Log data BEFORE updating dynamics
            action_log[step, agent_idx, :] = u
            pos_log[step, agent_idx, :] = agent.pos
            vel_log[step, agent_idx, :] = agent.vel
            heading_log[step, agent_idx] = heading

            # Check for freezing
            if norm(agent.vel) < 0.1
                freezing_count += 1
            end

            # Update agent dynamics using unicycle model (v6.3: kinematic model)
            Dynamics.step_unicycle!(agent, u, agent_params, world_params, Obstacle[], agents)

            # Note: No goal cycling needed - agents move continuously in their assigned direction
            # Torus boundary allows infinite motion in the same direction
        end
    end

    # Compute metrics
    total_agent_steps = length(agents) * MAX_STEPS
    collision_rate = 100.0 * collision_count / total_agent_steps
    near_collision_rate = 100.0 * near_collision_count / total_agent_steps
    freezing_rate = 100.0 * freezing_count / total_agent_steps

    # Save to HDF5 with v6.3 extended structure
    h5open(log_path, "w") do file
        # Trajectory data group
        traj_group = create_group(file, "trajectory")
        # pos_log is [T, N, 2], need [2, N, T] for HDF5
        traj_group["pos", compress=4] = collect(permutedims(pos_log, (3, 2, 1)))  # [2, N, T]
        traj_group["vel", compress=4] = collect(permutedims(vel_log, (3, 2, 1)))  # [2, N, T]
        traj_group["u", compress=4] = collect(permutedims(action_log, (3, 2, 1)))  # [2, N, T]
        traj_group["heading", compress=4] = collect(permutedims(heading_log, (2, 1)))  # [N, T]

        # NEW in v6.3: Extended trajectory data
        traj_group["goal", compress=4] = collect(permutedims(goal_log, (2, 1)))  # [2, N]
        traj_group["d_pref", compress=4] = collect(permutedims(d_pref_log, (3, 2, 1)))  # [2, N, T]
        traj_group["group"] = group_log  # [N]

        # Obstacles group
        obs_group = create_group(file, "obstacles")
        if !isempty(obstacles)
            obs_matrix = collect(hcat([[o[1], o[2]] for o in obstacles]...)')
            obs_group["data", compress=4] = permutedims(obs_matrix, (2, 1))  # [2, M]
        else
            obs_group["data"] = zeros(Float32, 2, 0)
        end

        # NEW in v6.3: Events group (collision flags)
        events_group = create_group(file, "events")
        # collision_flag_log is [T, N], keep as is for consistency with trajectory
        events_group["collision", compress=4] = collect(permutedims(collision_flag_log, (2, 1)))  # [N, T]
        events_group["near_collision", compress=4] = collect(permutedims(near_collision_flag_log, (2, 1)))  # [N, T]

        # Metadata group
        meta_group = create_group(file, "metadata")
        meta_group["scenario"] = scenario
        meta_group["density"] = density
        meta_group["seed"] = seed
        if scenario == "corridor"
            meta_group["corridor_width"] = corridor_width
        end
        meta_group["n_agents"] = length(agents)
        meta_group["n_steps"] = MAX_STEPS
        meta_group["dt"] = world_params.dt
        meta_group["world_size"] = collect(scenario_params.world_size)  # NEW: World dimensions for viewer
        meta_group["collision_rate"] = collision_rate
        meta_group["near_collision_rate"] = near_collision_rate
        meta_group["freezing_rate"] = freezing_rate
        meta_group["exploration_noise"] = EXPLORATION_NOISE
        meta_group["safety_threshold"] = SAFETY_THRESHOLD
        meta_group["repulsion_strength"] = REPULSION_STRENGTH
        meta_group["controller_type"] = "RandomWalk_CollisionFree_v63"  # NEW: Document controller
        meta_group["timestamp"] = string(now())

        # SPM parameters group
        spm_group = create_group(file, "spm_params")
        spm_group["n_rho"] = V63_SPM_PARAMS.n_rho
        spm_group["n_theta"] = V63_SPM_PARAMS.n_theta
        spm_group["sensing_ratio"] = V63_SPM_PARAMS.sensing_ratio
        spm_group["r_robot"] = V63_SPM_PARAMS.r_robot
        spm_group["r_agent"] = agent_params.r_agent
    end

    println("    Collision rate: $(round(collision_rate, digits=3))% (Target: <0.1%)")
    println("    Near-collision rate: $(round(near_collision_rate, digits=2))%")
    println("    Freezing rate: $(round(freezing_rate, digits=2))%")

    if collision_rate > 0.1
        println("    ⚠️  WARNING: Collision rate exceeds target (0.1%)")
    else
        println("    ✅ Collision rate within target")
    end

    println("    ✅ Saved: $log_path")

    # Force garbage collection
    GC.gc()

    return log_path, collision_rate, near_collision_rate
end

# Main execution
println("Starting data collection...")
println()

# Run simulations for all conditions
simulation_count = 0
total_collision_rate = 0.0
total_near_collision_rate = 0.0

for scenario in SCENARIOS
    if scenario == "corridor"
        for width in CORRIDOR_WIDTHS
            for density in DENSITIES
                for seed in SEEDS_RANGE
                    global simulation_count += 1
                    _, coll_rate, near_coll_rate = run_single_simulation(scenario, density, seed, width)
                    global total_collision_rate += coll_rate
                    global total_near_collision_rate += near_coll_rate
                end
            end
        end
    else
        for density in DENSITIES
            for seed in SEEDS_RANGE
                global simulation_count += 1
                _, coll_rate, near_coll_rate = run_single_simulation(scenario, density, seed)
                global total_collision_rate += coll_rate
                global total_near_collision_rate += near_coll_rate
            end
        end
    end
    println()
end

avg_collision_rate = total_collision_rate / simulation_count
avg_near_collision_rate = total_near_collision_rate / simulation_count

println("="^80)
println("Data Collection Complete")
println("="^80)
println("  Total simulations: $simulation_count")
println("  Average collision rate: $(round(avg_collision_rate, digits=3))% (Target: <0.1%)")
println("  Average near-collision rate: $(round(avg_near_collision_rate, digits=2))%")
println("  Output directory: $OUTPUT_DIR")
println()

if avg_collision_rate > 0.1
    println("⚠️  WARNING: Average collision rate exceeds target!")
    println("   Consider increasing safety_threshold or repulsion_strength")
else
    println("✅ SUCCESS: Collision rate within target (<0.1%)")
end

println()
println("Next steps:")
println("  1. Compare with v6.2: Data quality, collision rates, diversity")
println("  2. VAE Training: Use new trajectory_loader_v63.jl")
println("  3. Train VAE: julia --project=. scripts/train_action_vae_v63.jl")
println("  4. Ablation Study: v6.2 (FEP-biased) vs v6.3 (Unbiased)")
println("="^80)
