#!/usr/bin/env julia

"""
Exploration Data Collection Script
Runs simulation with exploration noise to generate diverse SPM patterns for VAE training
"""

# Add src to load path
push!(LOAD_PATH, joinpath(@__DIR__, "..", "src"))

using Printf
using Dates

# Load modules
include("../src/config.jl")
include("../src/spm.jl")
include("../src/dynamics.jl")
include("../src/controller.jl")
include("../src/communication.jl")
include("../src/logger.jl")
include("../src/vae.jl")

using .Config
using .SPM
using .Dynamics
using .Controller
using .Communication
using .Logger
using .VAEModel
using BSON

"""
Main exploration data collection
"""
function main()
    println("=" ^ 60)
    println("ðŸ”¬ EXPLORATION DATA COLLECTION")
    println("=" ^ 60)
    
    # Load configuration with EXPLORATION ENABLED
    spm_params = DEFAULT_SPM
    world_params = DEFAULT_WORLD
    agent_params = DEFAULT_AGENT
    comm_params = DEFAULT_COMM
    
    # EXPLORATION CONFIG
    control_params = ControlParams(
        eta=1.0,
        sigma_safe=3.0,
        T_th=2.0,
        beta_ttc=2.0,
        epsilon=1e-6,
        exploration_rate=0.2,     # 20% random actions
        exploration_noise=0.1     # 10% noise on FEP actions
    )
    
    println("\nðŸ“‹ Configuration:")
    println("  SPM: $(spm_params.n_rho)x$(spm_params.n_theta), FOV=$(spm_params.fov_deg)Â°")
    println("  Agents: $(agent_params.n_agents_per_group) per group (4 groups)")
    println("  âš¡ EXPLORATION ENABLED:")
    println("    Epsilon (random action): $(control_params.exploration_rate * 100)%")
    println("    Noise std: $(control_params.exploration_noise * 100)% of u_max")
    println("  Steps: $(world_params.max_steps)")
    
    # Initialize agents
    println("\nðŸ¤– Initializing agents...")
    agents = init_agents(agent_params, world_params)
    
    # Initialize obstacles
    println("\nðŸš§ Initializing obstacles...")
    obstacles = init_obstacles(world_params)
    
    # Initialize SPM
    println("\nðŸ—ºï¸  Initializing SPM...")
    spm_config = init_spm(spm_params)
    
    # Initialize communication
    println("\nðŸ“¡ Initializing ZMQ publisher...")
    publisher = init_publisher(comm_params)
    
    # Initialize HDF5 logger (save to data/exploration/)
    println("\nðŸ’¾ Initializing HDF5 logger...")
    timestamp = Dates.format(Dates.now(), "yyyymmdd_HHMMSS")
    if !isdir("data/exploration")
        mkpath("data/exploration")
    end
    log_filename = joinpath("data", "exploration", "eph_explore_$(timestamp).h5")
    data_logger = init_logger(log_filename, spm_params, world_params)
    println("  Output: $(log_filename)")
    
    # NO VAE MODEL for exploration data collection
    vae_model = nothing
    println("\nðŸ§  VAE: Disabled (pure data collection mode)")
    
    # Select agent for detailed logging
    detail_agent_id = 1
    
    println("\n" * "=" ^ 60)
    println("â–¶ï¸  Starting exploration simulation...")
    println("=" ^ 60)
    
    # Main simulation loop
    for step in 1:world_params.max_steps
        # Update each agent
        for agent in agents
            # Compute ego-centric frame rotation
                vel_norm = norm(agent.vel)
                rot_angle = Ï€/2  # Default: pointing north
                
                if vel_norm > 0.001
                    heading = atan(agent.vel[2], agent.vel[1])
                    rot_angle = -heading + Ï€/2
                end
                
                cos_Î¸ = cos(rot_angle)
                sin_Î¸ = sin(rot_angle)
                
                # Calculate FOV and sensing parameters
                r_total = spm_params.r_robot + agent_params.r_agent
                max_sensing_distance = spm_params.sensing_ratio * r_total
                
                # Get relative positions in ego-centric frame
                rel_pos_ego = Vector{Float64}[]
                rel_vel = Vector{Float64}[]
                local_agents = Vector{Vector{Float64}}[]
                
                for other in agents
                    if other.id != agent.id
                        r_rel_world = relative_position(agent.pos, other.pos, world_params)
                        dist = norm(r_rel_world)
                        
                        if dist > max_sensing_distance
                            continue
                        end
                        
                        r_rel_ego = [
                            cos_Î¸ * r_rel_world[1] - sin_Î¸ * r_rel_world[2],
                            sin_Î¸ * r_rel_world[1] + cos_Î¸ * r_rel_world[2]
                        ]
                        
                        theta_val = atan(r_rel_ego[1], r_rel_ego[2])
                        if abs(theta_val) > spm_params.fov_rad / 2
                            continue
                        end
                        
                        v_rel_world = other.vel - agent.vel
                        v_rel_ego = [
                            cos_Î¸ * v_rel_world[1] - sin_Î¸ * v_rel_world[2],
                            sin_Î¸ * v_rel_world[1] + cos_Î¸ * v_rel_world[2]
                        ]
                        
                        push!(rel_pos_ego, r_rel_ego)
                        push!(rel_vel, v_rel_ego)
                        push!(local_agents, [r_rel_ego[1], r_rel_ego[2], Float64(Int(other.group))])
                    end
                end
                
                # Generate SPM
                spm = generate_spm_3ch(spm_config, rel_pos_ego, rel_vel, agent_params.r_agent)
                
                # Compute action with EXPLORATION
                action = compute_action(agent, spm, control_params, agent_params)
                
                # Apply exploration
                if rand() < control_params.exploration_rate
                    # Random action
                    action = (rand(2) .* 2 .- 1) .* agent_params.u_max
                else
                    # FEP + noise
                    noise = randn(2) .* control_params.exploration_noise .* agent_params.u_max
                    action = action .+ noise
                end
                action = clamp.(action, -agent_params.u_max, agent_params.u_max)
                
                # Step dynamics
                step!(agent, action, agent_params, world_params, obstacles, agents)
                
                # Log detail for selected agent
                if agent.id == detail_agent_id
                    fe = free_energy(agent.vel, agent.goal_vel, spm, control_params)
                    haze = 0.0  # No VAE in exploration mode
                    
                    log_step!(data_logger, spm, action, agent.pos, agent.vel)
                    publish_detail(publisher, agent, spm, action, fe, haze, step, agents, world_params, comm_params, spm_params, agent_params, local_agents)
                end
            end
        end
        
        # Publish global state
        publish_global(publisher, agents, step)
        
        # Progress logging
        if step % 500 == 0
            @printf("Step %4d/%d | Exploration mode: Îµ=%.1f%%, Ïƒ=%.1f%%\\n",
                    step, world_params.max_steps,
                    control_params.exploration_rate * 100,
                    control_params.exploration_noise * 100)
        end
    end
    
    println("\n" * "=" ^ 60)
    println("âœ… Exploration data collection complete!")
    println("  Saved to: $(log_filename)")
    println("=" ^ 60)
    
    # Cleanup
    close_logger(data_logger)
    close(publisher.socket)
    println("\nðŸŽ‰ Done! Ready for VAE training with diverse data.")
end

main()
